"""
Vulnerability Analysis Engine

This module processes MobSF scan results and extracts vulnerability information
for AI analysis and report generation.
"""

import json
import logging
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime
from pathlib import Path

logger = logging.getLogger(__name__)


class VulnerabilityExtractor:
    """
    Extracts and processes vulnerability data from MobSF scan results
    """
    
    def __init__(self):
        """Initialize the vulnerability extractor"""
        self.vulnerability_mappings = self._load_vulnerability_mappings()
    
    def _load_vulnerability_mappings(self) -> Dict[str, Any]:
        """
        Load vulnerability type mappings and severity guidelines
        
        Returns:
            Dict[str, Any]: Vulnerability mappings and rules
        """
        return {
            "severity_keywords": {
                "critical": ["remote code execution", "sql injection", "authentication bypass", 
                           "privilege escalation", "arbitrary file write", "command injection"],
                "high": ["cross-site scripting", "insecure storage", "weak encryption", 
                        "information disclosure", "path traversal", "insecure communication"],
                "medium": ["weak hash", "insecure random", "debug enabled", "backup enabled",
                          "certificate pinning", "root detection"],
                "low": ["hardcoded strings", "logging", "debugging", "obfuscation", 
                       "code quality", "permissions"]
            },
            "category_mappings": {
                "authentication": ["auth", "login", "credential", "password", "token"],
                "encryption": ["encrypt", "crypto", "cipher", "hash", "ssl", "tls"],
                "storage": ["storage", "database", "file", "cache", "preference"],
                "network": ["network", "http", "url", "api", "communication"],
                "permissions": ["permission", "privilege", "access", "authorization"],
                "code_quality": ["code", "debug", "log", "comment", "unused"],
                "configuration": ["config", "setting", "manifest", "property"]
            }
        }
    
    def extract_vulnerabilities_from_mobsf(self, scan_results: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Extract vulnerability data from MobSF scan results
        
        Args:
            scan_results (Dict[str, Any]): Complete MobSF scan results
            
        Returns:
            List[Dict[str, Any]]: List of extracted vulnerabilities
        """
        logger.info("Extracting vulnerabilities from MobSF scan results")
        
        vulnerabilities = []
        
        # Extract from different sections of the MobSF report
        vulnerabilities.extend(self._extract_from_security_analysis(scan_results))
        vulnerabilities.extend(self._extract_from_code_analysis(scan_results))
        vulnerabilities.extend(self._extract_from_manifest_analysis(scan_results))
        vulnerabilities.extend(self._extract_from_binary_analysis(scan_results))
        
        # Add metadata to each vulnerability
        for i, vuln in enumerate(vulnerabilities):
            vuln['id'] = f"vuln_{i+1:03d}"
            vuln['extracted_at'] = datetime.now().isoformat()
            vuln['source'] = 'mobsf'
        
        logger.info(f"Extracted {len(vulnerabilities)} vulnerabilities from scan results")
        return vulnerabilities
    
    def _extract_from_security_analysis(self, scan_results: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Extract vulnerabilities from security analysis section"""
        vulnerabilities = []
        
        # Check various security-related sections
        security_sections = [
            'security_analysis',
            'android_api',
            'security',
            'vulnerabilities',
            'findings'
        ]
        
        for section in security_sections:
            if section in scan_results:
                section_data = scan_results[section]
                if isinstance(section_data, dict):
                    vulnerabilities.extend(self._process_security_dict(section_data, section))
                elif isinstance(section_data, list):
                    vulnerabilities.extend(self._process_security_list(section_data, section))
        
        return vulnerabilities
    
    def _extract_from_code_analysis(self, scan_results: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Extract vulnerabilities from code analysis section"""
        vulnerabilities = []
        
        code_sections = [
            'code_analysis',
            'source_code',
            'static_analysis',
            'sast'
        ]
        
        for section in code_sections:
            if section in scan_results:
                section_data = scan_results[section]
                if isinstance(section_data, dict):
                    for finding_type, findings in section_data.items():
                        if isinstance(findings, list):
                            for finding in findings:
                                vuln = self._create_vulnerability_from_finding(
                                    finding, f"code_{finding_type}", section
                                )
                                if vuln:
                                    vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _extract_from_manifest_analysis(self, scan_results: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Extract vulnerabilities from manifest analysis"""
        vulnerabilities = []
        
        manifest_sections = [
            'manifest_analysis',
            'manifest',
            'permissions',
            'activities',
            'services',
            'receivers'
        ]
        
        for section in manifest_sections:
            if section in scan_results:
                section_data = scan_results[section]
                vulns = self._process_manifest_data(section_data, section)
                vulnerabilities.extend(vulns)
        
        return vulnerabilities
    
    def _extract_from_binary_analysis(self, scan_results: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Extract vulnerabilities from binary analysis"""
        vulnerabilities = []
        
        binary_sections = [
            'binary_analysis',
            'binary',
            'dex_analysis',
            'libraries',
            'native_libraries'
        ]
        
        for section in binary_sections:
            if section in scan_results:
                section_data = scan_results[section]
                vulns = self._process_binary_data(section_data, section)
                vulnerabilities.extend(vulns)
        
        return vulnerabilities
    
    def _process_security_dict(self, data: Dict[str, Any], source: str) -> List[Dict[str, Any]]:
        """Process security-related dictionary data"""
        vulnerabilities = []
        
        for key, value in data.items():
            if isinstance(value, dict):
                # Check if this looks like a vulnerability entry
                if any(field in value for field in ['severity', 'description', 'title', 'risk']):
                    vuln = self._create_vulnerability_from_dict(value, key, source)
                    if vuln:
                        vulnerabilities.append(vuln)
                else:
                    # Recursively process nested dictionaries
                    vulnerabilities.extend(self._process_security_dict(value, f"{source}.{key}"))
            elif isinstance(value, list):
                vulnerabilities.extend(self._process_security_list(value, f"{source}.{key}"))
        
        return vulnerabilities
    
    def _process_security_list(self, data: List[Any], source: str) -> List[Dict[str, Any]]:
        """Process security-related list data"""
        vulnerabilities = []
        
        for item in data:
            if isinstance(item, dict):
                vuln = self._create_vulnerability_from_dict(item, "finding", source)
                if vuln:
                    vulnerabilities.append(vuln)
            elif isinstance(item, str):
                # Create vulnerability from string description
                vuln = self._create_vulnerability_from_string(item, source)
                if vuln:
                    vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _process_manifest_data(self, data: Any, source: str) -> List[Dict[str, Any]]:
        """Process manifest-related data"""
        vulnerabilities = []
        
        if isinstance(data, dict):
            for key, value in data.items():
                if key.lower() in ['dangerous_permissions', 'high_risk', 'vulnerabilities']:
                    if isinstance(value, list):
                        for item in value:
                            vuln = self._create_manifest_vulnerability(item, key, source)
                            if vuln:
                                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _process_binary_data(self, data: Any, source: str) -> List[Dict[str, Any]]:
        """Process binary analysis data"""
        vulnerabilities = []
        
        if isinstance(data, dict):
            for key, value in data.items():
                if key.lower() in ['security_issues', 'vulnerabilities', 'weaknesses']:
                    if isinstance(value, list):
                        for item in value:
                            vuln = self._create_binary_vulnerability(item, key, source)
                            if vuln:
                                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _create_vulnerability_from_dict(self, data: Dict[str, Any], vuln_type: str, source: str) -> Optional[Dict[str, Any]]:
        """Create vulnerability object from dictionary data"""
        try:
            vulnerability = {
                'title': data.get('title') or data.get('name') or data.get('rule') or vuln_type,
                'description': data.get('description') or data.get('desc') or data.get('message', ''),
                'severity': self._normalize_severity(data.get('severity') or data.get('risk') or data.get('level', 'medium')),
                'type': vuln_type,
                'source_section': source,
                'category': self._determine_category(data.get('title', '') + ' ' + data.get('description', '')),
                'file': data.get('file') or data.get('filename', ''),
                'line': data.get('line') or data.get('line_number', 0),
                'raw_data': data
            }
            
            # Add additional fields if available
            if 'cwe' in data:
                vulnerability['cwe'] = data['cwe']
            if 'owasp' in data:
                vulnerability['owasp'] = data['owasp']
            if 'references' in data:
                vulnerability['references'] = data['references']
            
            return vulnerability
            
        except Exception as e:
            logger.warning(f"Failed to create vulnerability from dict: {e}")
            return None
    
    def _create_vulnerability_from_finding(self, finding: Any, vuln_type: str, source: str) -> Optional[Dict[str, Any]]:
        """Create vulnerability from code finding"""
        if isinstance(finding, dict):
            return self._create_vulnerability_from_dict(finding, vuln_type, source)
        elif isinstance(finding, str):
            return self._create_vulnerability_from_string(finding, source, vuln_type)
        return None
    
    def _create_vulnerability_from_string(self, text: str, source: str, vuln_type: str = "finding") -> Optional[Dict[str, Any]]:
        """Create vulnerability from string description"""
        if not text or len(text.strip()) < 10:
            return None
        
        return {
            'title': text[:100] + "..." if len(text) > 100 else text,
            'description': text,
            'severity': self._guess_severity_from_text(text),
            'type': vuln_type,
            'source_section': source,
            'category': self._determine_category(text),
            'file': '',
            'line': 0,
            'raw_data': {'text': text}
        }
    
    def _create_manifest_vulnerability(self, item: Any, vuln_type: str, source: str) -> Optional[Dict[str, Any]]:
        """Create vulnerability from manifest analysis"""
        if isinstance(item, str):
            return {
                'title': f"Manifest Issue: {item}",
                'description': f"Manifest analysis identified: {item}",
                'severity': 'medium',
                'type': f"manifest_{vuln_type}",
                'source_section': source,
                'category': 'configuration',
                'file': 'AndroidManifest.xml',
                'line': 0,
                'raw_data': {'manifest_item': item}
            }
        elif isinstance(item, dict):
            return self._create_vulnerability_from_dict(item, f"manifest_{vuln_type}", source)
        return None
    
    def _create_binary_vulnerability(self, item: Any, vuln_type: str, source: str) -> Optional[Dict[str, Any]]:
        """Create vulnerability from binary analysis"""
        if isinstance(item, str):
            return {
                'title': f"Binary Issue: {item}",
                'description': f"Binary analysis identified: {item}",
                'severity': self._guess_severity_from_text(item),
                'type': f"binary_{vuln_type}",
                'source_section': source,
                'category': 'code_quality',
                'file': '',
                'line': 0,
                'raw_data': {'binary_item': item}
            }
        elif isinstance(item, dict):
            return self._create_vulnerability_from_dict(item, f"binary_{vuln_type}", source)
        return None
    
    def _normalize_severity(self, severity: str) -> str:
        """Normalize severity levels"""
        if not severity:
            return 'medium'
        
        severity = str(severity).lower().strip()
        
        if severity in ['critical', 'very high', 'severe']:
            return 'critical'
        elif severity in ['high', 'important']:
            return 'high'
        elif severity in ['medium', 'moderate', 'warning']:
            return 'medium'
        elif severity in ['low', 'minor', 'info', 'information']:
            return 'low'
        else:
            return 'medium'  # default
    
    def _guess_severity_from_text(self, text: str) -> str:
        """Guess severity level from text description"""
        text_lower = text.lower()
        
        for severity, keywords in self.vulnerability_mappings["severity_keywords"].items():
            if any(keyword in text_lower for keyword in keywords):
                return severity
        
        return 'medium'  # default
    
    def _determine_category(self, text: str) -> str:
        """Determine vulnerability category from text"""
        text_lower = text.lower()
        
        for category, keywords in self.vulnerability_mappings["category_mappings"].items():
            if any(keyword in text_lower for keyword in keywords):
                return category
        
        return 'other'  # default
    
    def filter_vulnerabilities(self, vulnerabilities: List[Dict[str, Any]], 
                             min_severity: str = 'low',
                             categories: Optional[List[str]] = None,
                             exclude_types: Optional[List[str]] = None) -> List[Dict[str, Any]]:
        """
        Filter vulnerabilities based on criteria
        
        Args:
            vulnerabilities (List[Dict[str, Any]]): List of vulnerabilities
            min_severity (str): Minimum severity level
            categories (Optional[List[str]]): Categories to include
            exclude_types (Optional[List[str]]): Types to exclude
            
        Returns:
            List[Dict[str, Any]]: Filtered vulnerabilities
        """
        severity_order = {'low': 1, 'medium': 2, 'high': 3, 'critical': 4}
        min_severity_level = severity_order.get(min_severity.lower(), 1)
        
        filtered = []
        
        for vuln in vulnerabilities:
            # Check severity
            vuln_severity_level = severity_order.get(vuln.get('severity', 'low').lower(), 1)
            if vuln_severity_level < min_severity_level:
                continue
            
            # Check categories
            if categories and vuln.get('category') not in categories:
                continue
            
            # Check excluded types
            if exclude_types and vuln.get('type') in exclude_types:
                continue
            
            filtered.append(vuln)
        
        logger.info(f"Filtered vulnerabilities: {len(filtered)} of {len(vulnerabilities)} passed filters")
        return filtered
    
    def deduplicate_vulnerabilities(self, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Remove duplicate vulnerabilities based on title and description similarity
        
        Args:
            vulnerabilities (List[Dict[str, Any]]): List of vulnerabilities
            
        Returns:
            List[Dict[str, Any]]: Deduplicated vulnerabilities
        """
        seen = set()
        deduplicated = []
        
        for vuln in vulnerabilities:
            # Create a simple hash based on title and description
            identifier = f"{vuln.get('title', '')[:50]}_{vuln.get('severity', '')}_{vuln.get('category', '')}"
            hash_key = hash(identifier.lower())
            
            if hash_key not in seen:
                seen.add(hash_key)
                deduplicated.append(vuln)
            else:
                logger.debug(f"Duplicate vulnerability filtered: {vuln.get('title', 'Unknown')}")
        
        logger.info(f"Deduplicated vulnerabilities: {len(deduplicated)} of {len(vulnerabilities)} unique")
        return deduplicated
    
    def get_vulnerability_statistics(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Generate statistics for vulnerability list
        
        Args:
            vulnerabilities (List[Dict[str, Any]]): List of vulnerabilities
            
        Returns:
            Dict[str, Any]: Vulnerability statistics
        """
        stats = {
            'total_count': len(vulnerabilities),
            'severity_breakdown': {'critical': 0, 'high': 0, 'medium': 0, 'low': 0},
            'category_breakdown': {},
            'source_breakdown': {},
            'type_breakdown': {}
        }
        
        for vuln in vulnerabilities:
            # Severity breakdown
            severity = vuln.get('severity', 'medium').lower()
            if severity in stats['severity_breakdown']:
                stats['severity_breakdown'][severity] += 1
            
            # Category breakdown
            category = vuln.get('category', 'other')
            stats['category_breakdown'][category] = stats['category_breakdown'].get(category, 0) + 1
            
            # Source breakdown
            source = vuln.get('source_section', 'unknown')
            stats['source_breakdown'][source] = stats['source_breakdown'].get(source, 0) + 1
            
            # Type breakdown
            vuln_type = vuln.get('type', 'unknown')
            stats['type_breakdown'][vuln_type] = stats['type_breakdown'].get(vuln_type, 0) + 1
        
        return stats


def create_vulnerability_extractor() -> VulnerabilityExtractor:
    """
    Factory function to create vulnerability extractor
    
    Returns:
        VulnerabilityExtractor: Configured extractor instance
    """
    return VulnerabilityExtractor()